from collections import deque 
 
def is_solvable(board): 
    flat_board = [num for row in board for num in row] 
    inversions = sum( 
        1 for i in range(len(flat_board)) for j in range(i + 1, len(flat_board)) 
        if flat_board[i] and flat_board[j] and flat_board[i] > flat_board[j] 
    ) 
    return inversions % 2 == 0 
 
def get_neighbors(board): 
    neighbors = [] 
    x, y = [(i, j) for i in range(3) for j in range(3) if board[i][j] == 0][0] 
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)] 
     
    for dx, dy in directions: 
        nx, ny = x + dx, y + dy 
        if 0 <= nx < 3 and 0 <= ny < 3: 
            new_board = [row[:] for row in board] 
            new_board[x][y], new_board[nx][ny] = new_board[nx][ny], new_board[x][y] 
            neighbors.append(new_board) 
     
    return neighbors 
 
def solve_puzzle(start_board): 
    goal_state = [[0, 1, 2], [3, 4, 5], [6, 7, 8]] 
    queue = deque([(start_board, [])]) 
    visited = set() 
    visited.add(tuple(map(tuple, start_board))) 
     
    while queue: 
        board, path = queue.popleft() 
        if board == goal_state: 
            return path + [board] 
         
        for neighbor in get_neighbors(board): 
            board_tuple = tuple(map(tuple, neighbor)) 
            if board_tuple not in visited: 
                visited.add(board_tuple) 
                queue.append((neighbor, path + [board])) 
     
    return None 
 
def print_puzzle_path(path): 
    for step, board in enumerate(path): 
        print(f"Step {step}:") 
        for row in board: 
            print(row) 
        print() 
 
# Example usage 
initial_state =  [[1, 2, 5], [3, 4, 0], [6, 7, 8]] 
if is_solvable(initial_state): 
    solution_path = solve_puzzle(initial_state) 
    if solution_path: 
        print_puzzle_path(solution_path) 
    else: 
        print("No solution found.") 
else: 
    print("Puzzle is not solvable.")
